\chapter{QF-Fragment of the Theory of Equality}
\label{cha:QF-Fragment of the Theory of Equality}

Non all the Logic formulas can be decided by a decision procedure:
\begin{itemize}
    \item \textbf{PL} (Propositional Logic) is decidable problem.
    \item \textbf{Fragment of FOL} is decidable problem.
    \item \textbf{FOL} (First-Order Logic) formula is valid is a semi-decidable problem.
    \item \textbf{FOL} formula is invalid is a non-semi-decidable problem.
    \item \textbf{HOL} (Higher-Order Logic) is undecidable problem.
\end{itemize}

In this paper we will focus on the \textbf{PL} and \textbf{FOL} formulas.

In particular we will focus on the \textbf{QF-Fragment of the Theory of Equality}
(QF-$\eqTheory$).

\section{Formulas in QF-Fragment of the TOE}
\label{sec:Formulas in QF-Fragment of the TOE}

The QF-$\eqTheory$ is the fragment of the first-order logic that contains only
quantifier-free formulas and the equality predicate.

The idea is to restrict the formulas to a certain form 
in order to make the problem decidable by the same decision procedure.

This ``\textit{prepocessing}'' can be done with the following steps:
\begin{enumerate}
    \item Remove all the quantifiers.
    \item Tranform the formula in NNF (\ref{def:Negation Normal Form}).
    \item Tranform the formula in DNF (\ref{def:Disjunctive Normal Form}).
    \item Removing all other predicate symbols except the equality predicate
    (\ref{rem:Functions of Predicate})
\end{enumerate}

In this way the formula is in the QF-$\eqTheory$, and it can be 
expressed as a conjunction of equalities and disequalities.

In this way if a block of the formula is false, the whole formula is unsatisfiable.

The QF-$\eqTheory$-Formula $F$ can also be expressed as a set of equations and disequations:
\begin{equation*}
    F = \{ s_i \eql t_i \}_{i=1}^{n} \cup \{ s_j \deql t_j \}_{j=n+1}^{n+m}
\end{equation*}
Where $s_i, t_i, s_j, t_j$ are terms.

\section{Congruence Closure of a Binary Relation}
\label{sec:Congruence Closure of a Binary Relation}

\begin{definition}{Binary Relation}
    A \textbf{binary relation} $R$ is a subset of the cartesian product 
    of a set $S$ and itself.
    \begin{equation*}
        R \subseteq S \times S
    \end{equation*}
\end{definition}

\begin{definition}{Equivalence Relation}
    A binary relation $R$ is an \textbf{equivalence relation} if it satisfies the 
    \textit{equivalence axioms} \ref{def:Equivalence Axioms} for the predicate.
    
\end{definition}

\begin{definition}{Congruence Relation}
    A equivalence relation $R$ is a \textbf{congruence relation} if it satisfies the 
    the \textit{congruence axioms} \ref{def:Congruence Axioms} for the predicate.
\end{definition}

\begin{definition}{Equivalence Class}
    Given a set $S$ and an equivalence relation $R$ on $S$, 
    the \textbf{equivalence class} of an element $s \in S$ is the set:
    \begin{equation*}
        [s]_R = \{ t \in S \; | \; sRt \}
    \end{equation*}
\end{definition}

\begin{example}{Modulo 2 Equivalence Class}
    Given the set $S = \mathbb{Z}$ and the equivalence relation $R$ defined as:
    \begin{equation*}
        sRt \iff s \equiv t \mod 2 \iff s \equiv_2 t
    \end{equation*}
    The equivalence class of $0$ is:
    \begin{equation*}
        [0]_{\equiv_2} = \{ \dots, -4, -2, 0, 2, 4, \dots \}
    \end{equation*}
\end{example}

\begin{definition}{Refinement}
    Let $R$ and $R'$ be two equivalence relations on a set $S$.
    The relation $R$ is a \textbf{refinement} of $R'$ if:
    \begin{equation*}
        \forall s,t \in S \; sRt \implies sR't
    \end{equation*}
    Which means $R \subsetneq R'$, and it is denoted as $R \refine R'$.  
\end{definition}

\begin{remark}{Refinement}
    We can say that the relation $R$ is a refinement of the relation $R'$.
    But $R'$ is not a refinement of $R$, in fact:
    \begin{equation*}
        \forall s,t \in S \; sR't \nRightarrow  sRt
    \end{equation*}
\end{remark}

\begin{example}{Refinement of Modulo 2 Class}
    We can say that the relation $\equiv_4$ is a refinement of the relation $\equiv_2$.
    \begin{equation*}
        \forall s,t \in \mathbb{Z} \; s \equiv_4 t \implies s \equiv_2 t
    \end{equation*}
\end{example}

[IMAGE OG CLASS EQUIVALENCE IN 8 OTTOBRE]

\begin{definition}{Partition}
    A \textbf{partition} of a set $S$ is a set of non-empty subsets of $S$:
    \begin{equation*}
        \{ S_1, S_2, \dots, S_n \}
    \end{equation*} 
    such that every element of $S$ is in exactly one of these subsets:
    \begin{itemize}
        \item $S_i \neq \emptyset$
        \item $S_i \cap S_j = \emptyset \quad \forall i \neq j$
        \item $\bigcup_{i=1}^{n} S_i = S$
    \end{itemize}
\end{definition}

\begin{definition}{Equilvance Closure}
    Let $R$ be a binary relation on a set $S$.
    The \textbf{equivalence closure} $R^E$ of $R$ such that:   
    \begin{itemize}
        \item $R^E$ is an equivalence relation
        \item $R^E$ covers $R$, $R \refine R^E$
        \item $R^E$ is the $\refine$-smallest equivalence relation 
        s.t. $R \subseteq R^E$, in other words
        if $\exists R': R \subseteq R'$ and $R'$ is an equivalence relation, 
        then $R^E \refine R'$.    
    \end{itemize}
\end{definition}

\begin{definition}{Congruence Closure}
    Let $R$ be a binary relation on a set $S$.
    The \textbf{congruence closure} $R^C$ of $R$ such that:   
    \begin{itemize}
        \item $R^C$ is a congruence relation
        \item $R^C$ covers $R$, $R \refine R^C$
        \item $R^C$ is the $\refine$-smallest congruence relation 
        s.t. $R \subseteq R^C$, in other words
        if $\exists R': R \subseteq R'$ and $R'$ is a congruence relation, 
        then $R^C \refine R'$.    
    \end{itemize}
\end{definition}

The idea is to use the congruence closure to check if a set of equalities and disequalities
are satisfiable ($R = \eql$).

If the congruence closure of the set is the equality relation put 
an equivality relation and a disequality relation in the same 
equivalence class, then the formula is unsatisfiable.

\section{Congruence Closure Algorithm}
\label{sec:Congruence Closure Algorithm}

The \textbf{Congruence Closure Algorithm} is an algorithm that computes the
congruence closure of a binary relation, and it is used to check the satisfiability
of a set of equalities and disequalities.

\subsection{Idea of the CCA}
\label{subsec:Idea of the CCA}

Let a set of equalities and disequalities $F$:
\begin{equation*}
    F = \underbrace{\{ s_i \eql t_i \}_{i=1}^{n}}_{F^+} 
    \cup \underbrace{\{ s_j \deql t_j \}_{j=n+1}^{n+m}}_{F^-}
\end{equation*}
we want to check if $F$ is satisfiable.

We construct the set of all terms of $F$:
\begin{equation*}
    S_F = \{ s_i \; | \; i = 1, \dots, n+m\} \cup \{ t_i \; | \; i = 1, \dots, n+m\}
\end{equation*}
    
We need to find an interpretation $\I$ that satisfies $F$ such that:
\begin{itemize}
    \item $\I = (S_F,\inteFunc)$
    \item $\inteFunc(\eql) = \; \sim \; \subseteq S_F \times S_F$ 
    congruence relation over the terms classes
    \item 
    $\begin{cases*}
        \I \vDash s_i \eql t_i & \\
        \I \nvDash s_j \eql t_j & 
    \end{cases*}
    \iff
    \begin{cases*}
        [s_i]_{\I} \sim [t_i]_{\I} & $\forall i = 1, \dots, n$ \\
        [s_j]_{\I} \nsim [t_j]_{\I} & $\forall j = n+1, \dots, n+m$
    \end{cases*}$
\end{itemize}

So we can follow the following steps:
\begin{enumerate}
    \item Construct the set of terms $S_F$.
    \item Construct the initial congruence relation using the equalities 
    in $F^+$ forming a sort of partiton $P_F$.
    \item Continue to refine $P_F$ using the equalities
    in $F^+$.
    \item If a equality in $P_F$ is found in $F^-$, then the formula is unsatisfiable.
    \item If all the equalities in $F^+$ are in $P_F$,
    so that the set has only one conguence class, then the formula is satisfiable.
\end{enumerate}

\begin{example}{Congruence Closure Algorithm - SAT}
    Let $F = \{ x \eql y \land f(x) \eql f(z) \}$ and compute the congruence closure algorithm 
    of $F$.
    \begin{equation*}
        S_F = \{ x, y, f(x), f(z) \}
    \end{equation*}
    We start with the initial partition:
    \begin{equation*}
        P_F = \{ \{ x, y \}, \{ f(x), f(z) \} \}
    \end{equation*}
    For the congruence axioms \ref{def:Congruence Axioms} we have:
    \begin{equation*}
        x \eql y \implies f(x) \eql f(y)
    \end{equation*}
    So we refine the partition:
    \begin{equation*}
        P_F = \{ \{ x, y, f(x), f(y) \} \}
    \end{equation*}
    $P_F$ has only one equivalence class, so the formula is satisfiable.
\end{example}

\begin{example}{Congruence Closure Algorithm - UNSAT}
    Let $F = \underbrace{f^{(5)} \eql x}_{EQ1} \land \underbrace{f^{(3)} \eql x}_{EQ2} 
    \land \underbrace{f(x) \deql x}_{DEQ}$.
    \begin{equation*}
        S_F = \{ f^{(5)}(x), f^{(4)}(x), f^{(3)}(x), f^{(2)}(x), f(x), x \}
    \end{equation*}
    The initial partition is:
    \begin{equation*}
        P_F = 
        \{ \{ f^{(5)}(x)\}, \{ f^{(4)}(x)\}, \{ f^{(3)}(x)\}, \{ f^{(2)}(x)\}, \{ f(x)\},\{ x\}\}
    \end{equation*}
    We refine the partition with the equalities:
    \begin{align*}
        P_F &\stackrel{EQ1}{=} 
        \{ \{ f^{(5)}(x), x \},\{ f^{(4)}(x)\},\{ f^{(3)}(x)\},\{ f^{(2)}(x)\},\{ f(x)\},\{ x\}\} \\
        &\stackrel{EQ2}{=} 
        \{ \{ f^{(5)}(x), f^{(3)}(x), x \},\{ f^{(4)}(x)\},\{ f^{(2)}(x)\},\{ f(x)\},\{ x\}\} \\
        &\stackrel{EQ1 \land EQ2}{=}
        \{ \{ f^{(5)}(x), f^{(3)}(x), f^{(2)}(x), x \},\{ f^{(4)}(x)\},\{ f(x)\},\{ x\}\} \\ 
        &\stackrel{f^{(2)}(x) \eql x \land f(x) \deql x}{=}
        \{ \{ f^{(5)}(x), f^{(3)}(x), f^{(2)}(x), f(x), x \},\{ f^{(4)}(x)\}\}
    \end{align*}
    Since the disequality $f(x) \deql x$ is in the partition, the formula is unsatisfiable.
\end{example}

\subsection{Algorithm of CCA}
\label{subsec:Algorithm of CCA}

We can express the congruence classes as a Directed Acyclic Graph (DAG) 
where the nodes are the terms and the edges are the equalities.

[IMAGE OF DAG FROM 15 OTTOBRE]

We can define the data structure of the nodes of the DAG as:

\begin{codee}{Node Stucture}
    \code{../code/Node.java}{}{java}
\end{codee}

The Node data structure will rappresent a singular term.

Then we can define some basic functons:

\begin{codee}{Node Function}
    \code{../code/GetNode.java}{}{java}
\end{codee}

\begin{codee}{Find Function}
    \code{../code/FIND.java}{}{java}
\end{codee}

\begin{codee}{Ccpar Function}
    \code{../code/CCPAR.java}{}{java}
\end{codee}

These functions will retrive the respective object.

We then define the Union Function wich will unite due nodes
in a sigle congruence class:

\begin{codee}{Union Function}
    \code{../code/UNION.java}{}{java}
\end{codee}

But before the union, we need to check if the terms 
are congruent with each other, we define a function to do so:

\begin{codee}{Congruent Function}
    \code{../code/CONGRUENT.java}{}{java}
\end{codee}

We in the end define a function that procede 
to check if two terms of a class are congruent and union them if so,
also, ccpar and rappresentative (find), are modified to respect 
these invariants for a \textbf{Rappresentative Node}:
\begin{itemize}
    \item \texttt{n.id == n.fint}
    \item \texttt{n.ccpar =} $\varnothing$
\end{itemize}

\begin{codee}{Merge Function}
    \code{../code/MERGE.java}{}{java}
\end{codee}

\subsection{Complexity of CCA}
\label{subsec:Complexity of CCA}

Let $n$ be the number of nodes and $e$ 
the number of edges in the initial DAG.

The complexity of the CCA is $O(e^2)$ for $O(n)$ calls of the merge function.
Some optimizations can be done to reduce the complexity to $O(e \log e)$
for $O(n)$ calls of the merge function.

\subsection{Optimization of CCA}
\label{subsec:Optimization of CCA}

We can build a non recursive version of the FIND function:

\begin{codee}{Iterative Fine Function}
    \code{../code/ITER_FIND.java}{}{java}
\end{codee}

This function will find the representative of a node in a non recursive way,
with the assumption that all the nodes of the non rappresentative nodes
have the rappresentative node as the choosen node for the congruence class,
during the union operation.

We can also apply an euristic to reduce the number of node to unite 
in the union operation, by choosing the node with the largest 
ccpar set as the representative node:

\begin{codee}{Union Function with Euristic}
    \code{../code/EUR_UNION.java}{}{java}
\end{codee}

In the end we can add a forbidden set to the node structure,
to check forbidden merges (contraddictions), and avoid them:

\begin{codee}{Forbidden Set Euristic}
    \code{../code/FORBIDDEN.java}{}{java}
\end{codee}

In this case we can check if the merge is forbidden, and if so
interrupt the entire algorithm using the \texttt{unsatFlag}.

